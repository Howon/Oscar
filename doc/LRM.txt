Oscar
Functional, Actor based Programming Language


Manager: Ethan Adams EA2678
Language Guru: Howon Byun HB2458
System Architect: Jibben Lee Grabscheid Hillen JLH2218
System Architect: Vladislav Sergeevich Scherbich VSS2113
Tester: Anthony James Holley AJH2186






Introduction
Lexical Conventions
Keywords


Introduction
We will be implementing an Actor-Oriented Language. We all know there are difficulties associated with parallel computation, namely data collision when multiple threads access the same data. Most often, this requires explicitly defining locks and mutexes to control data access to resolve this issue, which adds significant mental and code overhead. The Actor model is a different approach to this problem that relies on the concept of message-passing between processes. The model simplifies the aforementioned difficulties of multiprocessing by abstracting explicit method calls, and relying on each “actor” to handle tasks and encapsulate mutable data. We would like to construct our language based off Erlang and Akka framework.


Lexical Conventions
One of the main goals of Oscar is to be consistent and clear. In languages like Java, there are way too many syntactic sugars that lend itself to inconsistent coding conventions. For example, arrays contain value of length yet ArrayLists rely on size(). In Oscar, all contains use the same convention of initializing with [value1, value2, ...] to maintain consistency and ease of development by preventing developers from having to lookup different APIs for achieving the same goal.


Identifiers
Identifiers consist of ASCII characters that must start with a letter then followed any combination of letters and numbers. In other words, it must follow this regex


[‘a’-’z’ ‘A’-‘Z’][‘a’-‘z’ ‘A’-‘Z’ 0-9]*
Whitespace
Any combination of tabs, spaces and new lines are allowed. Unlike Python, Oscar is not whitespace sensitive. Semicolons are used for statement separation


Keywords
Keyword
	Usage
	Example
	mut
	Declaration for mutable data
Inside actors only
	mut int i = 5;
i = 4;
	actor
	Actor as a first class object
	actor Worker {}
	die
	Kills the actor and all actors spawned by this actor
	receive() => die();
	spawn
	Used to spawn actors and pools
	spawn Worker(“worker”);
spawn pool(“worker pool”);
	pool
	Construct used to manage a collection of workers
	pool p = spawn pool(“worker pool”);
	sender
	Source worker of the message
	message(“hi”) |> sender;
[a][b][c]	
message
	Signal between actors and pools
	message(“hi”) |> sender;
	return
	Return
	def f(x: int) -> () => return x;
	to/by
	For loop range and loop increment/decrementer
	[i <- 0 to 5 by 2].map(i => { 
  return = i + 4;
});
	int
	Integer data type
	int x = 4;
	double
	Double data type used for floating point arithmetics
	double d = 4.4;
	char
	Characters
	char c = ‘c’;
	bool
	Boolean data type. Lowercase true/false 
	bool lie = true;
	string
	String
	string str = “hi”;
	maybe/none/some
	Optional type. “Null” should be wrapped with none in our language
	maybe<int> m = some<int>(404);
maybe<int> n = none;
	list
	List backed with HAMT[1] for persistence with performance. Remember, no arrays
	list<int> intList = [1, 2, 3];
	def
	Functions
	def f(x: int) : () => return x;
	tup
	Tuple
	tup<int, int[d][e][f][g][h]> t = (1, 4);
	Punctuations
Punctuation
	Usage
	Example
	.
	Decimal part indicator[i][j]
	41.17
	,
	List separator
	list<int> a = [1, 2, 3, 4, 5];
	;
	Statement separator
	int x = 4; int j = 4;
	[]
	List/set/map declaration
	list<int> a = [1, 2, 3, 4, 5];
	[]
	List/set/map/tuple getter
	a[1]; // 1
	{}
	Statement block
	if (true) { println(“hi”); }
	()
	Conditional delimiter
	if (false) { }
	()
	Tuple construction
	tup<int, int> t = (1, 4);
	()
	Function arguments declaration
	def func(arg: type) => {}
	‘’
	Character literal
	char c = ‘a’;
	“”
	String literal
	String str = “hi”;
	<>
	List type
	list<string> strList = [“hi”];
	/* */
	Multi-line comment
	/* hi
 * hello
 */
	//
	Single line comment
	// here
	

Operators
Operator
	Usage
	Associativity
	+
	Addition
	Left
	-
	Subtraction
	Left
	*
	Multiplication
	Left
	/
	Division
	Left
	%
	Modulo
	Left
	=
	Assignment
	Right
	==
	Equal to
	None
	!=
	Not equal to
	None
	>
	Greater than
	None
	>=
	Greater than or equal to
	None
	<
	Less than
	None
	<=
	Less than or equal to
	None
	&&
	Logical AND
	Left
	||
	Logical OR
	Left
	&
	Bitwise AND
	Right
	|
	Bitwise OR
	Right
	^
	Bitwise XOR
	Right
	<<
	Bitwise left shift
	Right
	>>
	Bitwise right shift
	Right
	~
	Bitwise NOT
	Right
	()
	Function invocation
	Right
	.
	Method application
	Left
	:
	Function argument type declaration
	Left
	=>
	Function return type declaration
	Left
	->
	Map key-value pair
	Left
	|>
	Send a message to an actor
	Left
	|>>
	Broadcast a message to a pool
	Left
	

Precedence as would be in ocamlyacc 
=                 <---         low
,
: -> => 
&& ||
& ^ |
< <= > >= == !=
<< >>
+ -
* / %
~
|> |>>
.         <--- high


Types
By default, everything is immutable in Oscar. This means that values cannot be re-assigned and container values return a new copy of the container when modified.


Primitive Types
Keyword
	Usage
	Example
	int
	Integer data type
	int x = 4;
	double
	Double data type used for floating point arithmetics
	double d = 4.4;
	char
	Characters
	char c = ‘c’;
	bool
	Boolean data type. Lowercase true/false 
	bool lie = true;
	unit
	Unit
	def nothing() -> unit => println();
	

Integer   “‘-’?[‘0’-‘9’]+”
An integer type is a signed 4 byte value of digits 
        int x = 5;
        x = 4; // error


Floating Point Numbers   “‘-’?[‘0’-’9’]+‘.’[‘0’-’9’]*”
Oscar uses double for floating point numbers. A double is a signed 8 byte double-precision floating point data like that in Java. Fractional part can be omitted.
        double x = 5.4;
        double y = -3.4;
        double z = 3.;


Implicit castings are not allowed
        double error = 3; // error
        int error2 = 2.4; // error


Arithmetic operations with double always modify the return type to double
        5 / 2 == 2;
        5 / 2. == 5./2 == 5.0/2. == 2.5;


Character  “\‘((‘a’-‘z’|‘A’-‘Z’)|‘\\’[‘\\’ ‘*’ ‘n’ ‘r’ ‘t’ ‘“’ ‘‘’])\’”
A character is a 1 byte data consisting of ASCII values. 
        char c = ‘c’;
        c - ‘f’ == -2; // true




Boolean  “true”|“false”
Boolean values take 1 byte and can be either true or false. Other data types cannot be casted as boolean. For example, none cannot be used as false
        bool t = true;


Unit
Unit type is purely for functions that do not return any value
        def println(s: string) => unit = { }


Non-Primitive Types
Keyword
	Usage
	Example
	string
	String
	string str = “hi”;
	maybe/none/some
	Optional type. “Null” should be wrapped with none in our language
	maybe<int> m = some<int>(404);
maybe<int> n = none;
	list
	List backed with HAMT[2] for persistence with performance. 
	list<int> intList = [1, 2, 3];
list<char> charList = list<char>[];
	set
	Set of unique values
	set<int> tSet = [1, 2, 3]
	map
	Map of key value pairs
	map<int, string> tMap = [0 -> “hi”]
	tup
	Tuple
	tup<int, int> t = (1, 4)
	actor
	Actor as a first class object
	actor Worker {}
	message
	Signal between actors and pools
	message(“hi”) |> sender;
	pool
	Construct used to manage a collection of workers
	pool p = spawn pool(“worker pool”);
	def
	Functions
	def f(x: int) -> unit => return x;
	

String  “\“[char]*\””
A string is just a character list like found in C++. They come with a few built-in functions for convenience. Since strings are list backed, built-in operations for lists apply to strings as well.
        string hi = “hello world”;
        hi[0] == ‘h’;
        me == “hello world”; // == on strings compare values
        me.size() == 11;
        me.substring(0, 6); // “hello”
        me.filter(x:char -> char => x != ‘l’) == “heo word”;


Optional
Oscar supports optional values for NullPointerException-safety.
        maybe<int> perhaps = some<int>(0);
        maybe<int> no = none;
Type optional has a very simple api for safely interacting with values
        perhaps.isDefined() == true;
        no.isDefined() == false;
        no.isNone() == true;
        perhaps.get() == 0;
        no.get() == None;
        perhaps.map(x:int -> double => x + 5.4); // some<double>(5.4);
For example,
        def printMaybe(x: maybe<int>) => unit = {
  if (x.isDefined()) {
    println(x.get());
  }
}


List
A list is a mutable collection of values of the same type.
        list<int> intList = list<int>[]; // empty list of type int
list<double> listSizeTen = list<double> (10, 0.0); 
// size 10 of 0.0’s
list<int> intList = [1, 2, 3, 4, 5]; // list literal
list<double> intList = [1, 2.0, 3, 4, “5”];// ERROR


Since everything without mut keyword is immutable, assignment just returns a new list with assignment applied
        let changedList = (initList[3] = -4)
changedList == [1, 2, 3, -4, 5]
initList == [1, 2, 3, 4, 5]
If declared with mut, lists behave like vectors in C++
mut let mutableList = [1, 2, 3, -4, 5]
let alteredList = (mutableList[3] = 5);
mutableList == alteredList == [1, 2, 3, 5, 5]
Type list has a few built-in functions. Here are some
        list<int> exam = [1, 2, 3, 4, 5];
        exam[0] == 1;
        exam.slice(0, 4) == [1, 2, 3];
        exam.size() == 5;
        list<int> prepend = exam.prepend(0); // [0, 1, 2, 3, 4, 5];
        list<int> append = exam.append(6); // [1, 2, 3, 4, 5, 6];
        list<int> popFront = exam.popFront(); // [2, 3, 4, 5];
        list<int> popBack = exam.popBack(); // [1, 2, 3, 4];
        exam.contains(0); // true
        exam.foreach(x:int => unit = {
println(x) // prints elements of exam
}); 
        exam.filter(x:int => int = x % 2 == 0); // [2, 4]
        exam.map(x:int => int = x + 2); // [3, 4, 5, 6, 7]
        exam.foldLeft((x:int, y:int) => int = x + y); // 15
List comprehension can also be used to declare lists.
list<int> comp = [int i <- 0 to 10 by 2]; // [0, 2, 4, 6, 8]
[int i <- 0 to 5 by 2].map(i:int => int = {
  return i + 4;
}).reduce((x:int, y:int) => int = x + y) // == 14


Set/Map
A set is a collection of distinct elements of the same type.
        set<int> intSet = [1, 2, 3, 4, 5];
        set<int> dupIntSet = [1, 2, 3, 4, 5, 1];
        set<int> intSetTwo = [1, 2, 3, 7, 8, 9];
        intSet == dupIntSet;
        intSet.contains(3) == true;
        intSet.contains(-3) == false;
        intSet.intersect(intSetTwo); // [1, 2, 3]
        intSet.union(intSetTwo); // [1, 2, 3, 4, 5, 7, 8, 9]
        intSet.diff(intSetTwo); // [4, 5]
        intSetTwo.diff(intSet); // [7, 8, 9]
intSet.add(8); // intSet stays, returns a new set with 8 added
Similarly, maps are collections of key value pairs.
        map<int, double> tMap = [0 -> 1.1, 4 -> 5.3, -3 -> 5.3];
map<int, double> tMapCpy = [0 -> 1.1, 4 -> 5.3, -3 -> 5.3];
map<int, double> errMap = [0 -> 1]; // ERROR as int != double
map<int, double> errMap2 = [0 -> 1.2];
map<int, double> union = [2 -> 1.2];
tMap.size() == 3;
tMap == tMapCpy; // compares all key-value pairs
tMap.union(union) == [0 -> 1.1, 4 -> 5.3, -3 -> 5.3, 2 -> 1.2];
tMap.union(errMap2); // error as key 0 exist in both maps
        tMap.contains(0) == true;
tMap.add(4 -> 5.3); // tMap stays, returns a new map
tMap.remove(0); // tMap stays, returns a new map without 0 -> 1.1


Get operations are protected through use of optionals
        tMap[0] == some<int>(1.1);
        tMap[2] == none;


Like lists, sets and maps can be declared with mut keyword inside actor context to make them mutable.
        map<int, double> tMap = [0 -> 1.1, 4 -> 5.3, -3 -> 5.3];
map<int, double> unionMap = [2 -> 1.2];
        tMap.add(5 -> 4.3);
        tMap == [0 -> 1.1, 4 -> 5.3, -3 -> 5.3, 5 -> 4.3];
        tMap[-3] = 3.4; //[0 -> 1.1, 4 -> 5.3, -3 -> 3.4, 5 -> 4.3];
        tMap.remove(4);
        tMap == [0 -> 1.1, -3 -> 5.3, 5 -> 4.3];
        tMap = tMap.union(unionMap);
                // [0 -> 1.1, 4 -> 5.3, -3 -> 5.3, 2 -> 1.2];


Tuple
Tuples are like structs. These can be used for conveniently wrapping multiple values of different types.
        tuple<int, string, double> tup = (1, “23”, 2.3);
        tup[0] == 1;
        tup[2] == “23”;


Tuples can be destructed into values on the left hand side;
        int i, string s, double d = tup;
        i == 1;
        s == “23”;
        d == 2.3;        


mut tuples can have their contents changed but their types are immutable
        mut tuple<int, string, double> mutTup = (1, “23”, 2.3);
        tup[0] = 2; 
mutTup == (2, “23”, 2.3);        
        tup[0] = 2.4; // ERROR 
Actor
Actors refer to units of concurrency processing defined in the Actor Model.[3] Oscar elevates these into first class constructs.
Actors are special. They can hold variables, declared using mut keyword. Also, all actors must define receiver function to handle messages. spawn keyword is used to create them.
actor Worker(initValue: int) { // accessible immutable value
  mut int x = 10 // allowed within actors
  x = 14 // x == 14 now since x was declared to be mutable
  let receive = { // all actors must have receive method defined
    | messageType1(name: string) => // do something 1
    | end() => die() // used to kill this actor and 
                     // all other workers declared in this actor
  } 
}


actor worker = spawn Worker(3);
worker.initValue == 3;
worker.initValue = 4; // ERROR as immutable outside the actor
worker.x; // ERROR as x is declared inside actor
Pool
pool manages a group of actors. When messages are sent into a pool, they are distributed in a round-robin fashion so that many actors can work concurrently.
pool workerPool = spawn pool(Worker(5), 10) 
// puts ten workers into a pool
pool workerPool2 = spawn pool(worker, Worker(3))
        pool workerPool3 = spawn pool(workerPool, Worker(4))


Message
Messages constructs used in inter-actor communications. They are structurally similar to tuples but hold extra data and operations. |> operator is used to send a message to actors and pools;
        message message(msg: string, payload: double)
message helloMessage(prefix: string, suffix: string) 
        helloMessage(“Hello”, “World!”) |> worker 
helloMessage(“everyone gets a”, “ message!”) |>> workerPool
// list of messages can be mass broadcasted
[msg1, msg1, msg1] |>> workerPool
sender keeps track of the source actor of a message. This can be used to bounce back a message to whomever sent it.
helloMessage(“hi”, “there”) |> sender


Function
Functions are declared with def keyword. In Oscar, functions are declared using arrow syntax like in ECMAScript 2016 and how most lambda function are declared.
def <identifier>(arg: type, arg2: type2 …) => <return type> = {
  return;
}
def addTwoNums(a: int, b: int): int => a + b 
int b = addTwoNums(a, 6);
b == 11;
Since functions are first class objects in Oscar, they can be passed into functions as well.
def apply(f: (double) => double, a: double) => double = {
  return f(a); // return is needed for multi-line functions
} // multi-line functions are surrounded with brackets
        def d = apply((x:double) => double = x * 2, 44.5) == 89.0
No argument functions are declared like this:
def sayHi() => unit = println(“hi!”) // void function
sayHi(); // prints “hi!”
Programming Structure
Actors
Printing actors ayy lmao
________________
[1] http://lampwww.epfl.ch/papers/idealhashtrees.pdf
[2] http://lampwww.epfl.ch/papers/idealhashtrees.pdf
[3] https://en.wikipedia.org/wiki/Actor_model
[a]This doesn't seem right
[b]why
[c]we're sending to sender?
[d]might we just want to infer how many elements are in the tuple?
[e]_Marked as resolved_
[f]_Re-opened_
[g]what
[h]should we just have tup<int> t = (1, 4);
[i]any other usages?
[j]Ur right